#include <stdio.h>
#include <stdlib.h>
#define limpa_tela system("cls") //limpa tela
#define espera sleep(1) //tempo de delay


//Função do quicksort, que recebe o limite
void quick_sort (int *nArray, int nLimite) {
  int nAnte, nProx, nMetade, nValAux, nAux;

  //Testando o limite e pegando a metade
  if (nLimite < 2)
    return;
  nMetade = nArray[nLimite / 2];

  //fazendo um for duplo, diminuindo o próximo e aumentando o anterior
  for (nAnte = 0, nProx = nLimite - 1;; nAnte++, nProx--) {
    //imprimindo os valores
    for(nAux=0;nAux<=nLimite-1;nAux++){
      printf("[%d]",nArray[nAux]);
      espera;
    }
    printf("\n");

    //enquanto for menor que a metade
    while (nArray[nAnte] < nMetade)
      nAnte++;
    //enquanto a metade for menor que o próximo
    while (nMetade < nArray[nProx])
      nProx--;
    //se o anterior é maior que o próximo quebra o laço
    if (nAnte >= nProx)
      break;

    //fazendo troca de posições
    nValAux = nArray[nAnte];
    nArray[nAnte] = nArray[nProx];
    nArray[nProx] = nValAux;
  }

  //Chamando rotina novamente em recursividade
  quick_sort(nArray, nAnte);
  quick_sort(nArray + nAnte, nLimite - nAnte);
}

main(){
  //declaração de variáveis
  int nPos=0, nAux=0;

  //Quantidade de casas do vetor
  while((nPos<=0)||(nPos>100)){
    printf("\nQuantos numeros tera o vetor? ");
    scanf("%d",&nPos);
  }

  //criando o vetor
  int nVetor[nPos], nOrig[nPos], nOpc=-1;

  //preenchendo os dados do vetor
  for(nAux=0;nAux<=nPos-1;nAux++){
    printf("\nInsira o numero %d: ",nAux+1);
    scanf("%d",&nVetor[nAux]);
    nOrig[nAux]=nVetor[nAux];
  }

  //Limpando a tela e pegando a opção
  limpa_tela;
  while((nOpc<=0)||(nOpc>=3)){
    printf("\n > Menu:");
    printf("\n  1. Shell Sort");
    printf("\n  2. Quick Sort");
    printf("\n > Resposta: ");
    scanf("%d",&nOpc);
  }
  printf("\nOrdenando:\n");

  //Se for Shell Sort
  if(nOpc==1){
    int nGap, nValAux, nProx, nAtual;

    //Definindo o gap
    while(nGap < (nPos-1)) {
      nGap = 2*nGap+1;
    }
    //Enquanto tiver o Gap
    while ( nGap > 1) {
      nGap /= 2;
      //Percorrendo as posições
      for(nAtual = nGap; nAtual < nPos; nAtual++) {
        //imprimindo os valores
        for(nAux=0;nAux<=nPos-1;nAux++){
          printf("[%d]",nVetor[nAux]);
          espera;
        }

        //definindo valor das próximas posições
        nValAux = nVetor[nAtual];
        nProx = nAtual - nGap;

        //Enquanto tiver próximo valor e ele seja menor que a próxima casa, faz inversão
        while (nProx >= 0 && nValAux < nVetor[nProx]) {
          nVetor[nProx + nGap] = nVetor[nProx];
          nProx -= nGap;
        }
        nVetor[nProx + nGap] = nValAux;
        printf("\n");
      }
    }
  }

  //Senão se for Quick Sort
  else if(nOpc==2){
    quick_sort(nVetor, nPos);
  }

  //Resultado - Vetor Original
  printf("\nOriginal: ");
  for(nAux=0;nAux<=nPos-1;nAux++){
    printf("[%d]",nOrig[nAux]);
    espera;
  }

  //Resultado - Vetor Ordenado
  printf("\nOrdenada: ");
  for(nAux=0;nAux<=nPos-1;nAux++){
    printf("[%d]",nVetor[nAux]);
    espera;
  }

  //limpando os dados e esperando o usuario apertar -Enter-
  getchar();
  printf("\n\nPressione -Enter- para finalizar!\n\n");
  getchar();
}
/*
//heap
void peneira(int *vet, int raiz, int fundo);

void heapsort(int *vet, int n) {
	int i, tmp;

	for (i = (n / 2); i >= 0; i--) {
		peneira(vet, i, n - 1);
	}

	for (i = n-1; i >= 1; i--) {
		tmp = vet[0];
		vet[0] = vet[i];
		vet[i] = tmp;
		peneira(vet, 0, i-1);
	}
}

void peneira(int *vet, int raiz, int fundo) {
	int pronto, filhoMax, tmp;

	pronto = 0;
	while ((raiz*2 <= fundo) && (!pronto)) {
		if (raiz*2 == fundo) {
			filhoMax = raiz * 2;
		}
		else if (vet[raiz * 2] > vet[raiz * 2 + 1]) {
			filhoMax = raiz * 2;
		}
		else {
			filhoMax = raiz * 2 + 1;
		}

	if (vet[raiz] < vet[filhoMax]) {
		tmp = vet[raiz];
		vet[raiz] = vet[filhoMax];
		vet[filhoMax] = tmp;
		raiz = filhoMax;
    }
	else {
      pronto = 1;
	}
  }
}

int main() {
	int vetor[max] = {5,2,7,8,10,6,1,4,9,3};
	int i;
	heapsort(vetor,max);
	for (i = 0; i < max; i++) {
		printf("%d ", vetor[i]);
	}
	return(0);
}

//merge
void merge(int *vet, int n) {
  int mid;
  int i, j, k;
  int *tmp;

  tmp = (int *) malloc(n * sizeof(int));
  if (tmp == NULL) {
  	printf("Memoria insuficiente.\n");
    exit(1);
  }

  mid = n / 2;

  i = 0;
  j = mid;
  k = 0;
  while (i < mid && j < n) {
    if (vet[i] < vet[j]) {
      tmp[k] = vet[i];
      i++;
    }
    else {
      tmp[k] = vet[j];
      j++;
    }
    k++;
  }

  if (i == mid) {
    while (j < n) {
      tmp[k] = vet[j];
      j++;
      k++;
    }
  }
  else {
    while (i < mid) {
      tmp[k] = vet[i];
      i++;
      k++;
    }
  }

  for (i = 0; i < n; ++i) {
    vet[i] = tmp[i];
  }

  free(tmp);
}

void mergesort(int *vet, int n) {
  int mid;

  if (n > 1) {
    mid = n / 2;
    mergesort(vet, mid);
    mergesort(vet + mid, n - mid);
    merge(vet, n);
  }
}

int main() {
	int vetor[max] = {5,2,7,8,10,6,1,4,9,3};
	int i;
	mergesort(vetor,max);
	for (i = 0; i < max; i++) {
		printf("%d ", vetor[i]);
	}
	return(0);
}*/
